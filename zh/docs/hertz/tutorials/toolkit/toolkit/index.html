<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.85.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>hz 命令行工具使用 | CloudWeGo</title><meta name=description content="A leading practice for building enterprise cloud native middleware!"><meta property="og:title" content="hz 命令行工具使用"><meta property="og:description" content="hz 是 Hertz 框架提供的一个用于生成代码的命令行工具。目前，hz 可以基于 thrift 和 protobuf 的 IDL 生成 Hertz 项目的脚手架。
安装  确保 GOPATH 环境变量已经被正确地定义（例如 export GOPATH=~/go）并且将$GOPATH/bin添加到 PATH 环境变量之中（例如 export PATH=$GOPATH/bin:$PATH）；请勿将 GOPATH 设置为当前用户没有读写权限的目录 安装 hz：  go install github.com/cloudwego/hertz/cmd/hz@latest 验证是否安装成功 hz -v, 如果显示如下版本的信息，则说明安装成功  hz version v0.1.0 注意，由于 hz 会为自身的二进制文件创建软链接，因此请确保 hz 的安装路径具有可写权限。
运行模式 要使用 thrift 或 protobuf 的 IDL 生成代码，需要安装相应的编译器：thriftgo 或 protoc 。
hz 生成的代码里，一部分是底层的编译器生成的（通常是关于 IDL 里定义的结构体），另一部分是IDL 中用户定义的路由、method 等信息。用户可直接运行该代码。
从执行流上来说，当 hz 使用 thrift IDL 生成代码时，hz 会调用 thriftgo 来生成 go 结构体代码，并将自身作为 thriftgo 的一个插件（名为 thrift-gen-hertz）来执行来生成其他代码。当用于 protobuf IDL 时亦是如此。"><meta property="og:type" content="article"><meta property="og:url" content="/zh/docs/hertz/tutorials/toolkit/toolkit/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2022-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-27T17:21:46+08:00"><meta property="og:site_name" content="CloudWeGo"><meta itemprop=name content="hz 命令行工具使用"><meta itemprop=description content="hz 是 Hertz 框架提供的一个用于生成代码的命令行工具。目前，hz 可以基于 thrift 和 protobuf 的 IDL 生成 Hertz 项目的脚手架。
安装  确保 GOPATH 环境变量已经被正确地定义（例如 export GOPATH=~/go）并且将$GOPATH/bin添加到 PATH 环境变量之中（例如 export PATH=$GOPATH/bin:$PATH）；请勿将 GOPATH 设置为当前用户没有读写权限的目录 安装 hz：  go install github.com/cloudwego/hertz/cmd/hz@latest 验证是否安装成功 hz -v, 如果显示如下版本的信息，则说明安装成功  hz version v0.1.0 注意，由于 hz 会为自身的二进制文件创建软链接，因此请确保 hz 的安装路径具有可写权限。
运行模式 要使用 thrift 或 protobuf 的 IDL 生成代码，需要安装相应的编译器：thriftgo 或 protoc 。
hz 生成的代码里，一部分是底层的编译器生成的（通常是关于 IDL 里定义的结构体），另一部分是IDL 中用户定义的路由、method 等信息。用户可直接运行该代码。
从执行流上来说，当 hz 使用 thrift IDL 生成代码时，hz 会调用 thriftgo 来生成 go 结构体代码，并将自身作为 thriftgo 的一个插件（名为 thrift-gen-hertz）来执行来生成其他代码。当用于 protobuf IDL 时亦是如此。"><meta itemprop=datePublished content="2022-06-18T00:00:00+00:00"><meta itemprop=dateModified content="2022-06-27T17:21:46+08:00"><meta itemprop=wordCount content="2407"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="hz 命令行工具使用"><meta name=twitter:description content="hz 是 Hertz 框架提供的一个用于生成代码的命令行工具。目前，hz 可以基于 thrift 和 protobuf 的 IDL 生成 Hertz 项目的脚手架。
安装  确保 GOPATH 环境变量已经被正确地定义（例如 export GOPATH=~/go）并且将$GOPATH/bin添加到 PATH 环境变量之中（例如 export PATH=$GOPATH/bin:$PATH）；请勿将 GOPATH 设置为当前用户没有读写权限的目录 安装 hz：  go install github.com/cloudwego/hertz/cmd/hz@latest 验证是否安装成功 hz -v, 如果显示如下版本的信息，则说明安装成功  hz version v0.1.0 注意，由于 hz 会为自身的二进制文件创建软链接，因此请确保 hz 的安装路径具有可写权限。
运行模式 要使用 thrift 或 protobuf 的 IDL 生成代码，需要安装相应的编译器：thriftgo 或 protoc 。
hz 生成的代码里，一部分是底层的编译器生成的（通常是关于 IDL 里定义的结构体），另一部分是IDL 中用户定义的路由、method 等信息。用户可直接运行该代码。
从执行流上来说，当 hz 使用 thrift IDL 生成代码时，hz 会调用 thriftgo 来生成 go 结构体代码，并将自身作为 thriftgo 的一个插件（名为 thrift-gen-hertz）来执行来生成其他代码。当用于 protobuf IDL 时亦是如此。"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QYWRQRLPRM"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-QYWRQRLPRM')</script><link rel=preload href=/scss/main.min.74596076870d8ffa5db36c241dd9869dba338426a102ea7b739db8693ea21df8.css as=style><link href=/scss/main.min.74596076870d8ffa5db36c241dd9869dba338426a102ea7b739db8693ea21df8.css rel=stylesheet integrity><script src=https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-QYWRQRLPRM','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/zh/><span class=navbar-logo><img src=/img/logo.png></span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="dropdown sub-menu"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><span>文档</span></a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh/docs/kitex/>Kitex</a>
<a class=dropdown-item href=/zh/docs/hertz/>Hertz</a>
<a class=dropdown-item href=/zh/docs/netpoll/>Netpoll</a></div></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh/about/><span>关于</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh/blog/><span>博客</span></a></li><li class="dropdown sub-menu"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><span>社区</span></a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh/community/>概述</a>
<a class=dropdown-item href=/zh/community/meeting_notes/>会议记录</a>
<a class=dropdown-item href=/zh/community/weekly_report/>周报</a></div></li><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav" id=td-section-nav><div class="nav-item dropdown d-block d-lg-none"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/>English</a></div></div><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-zhdocs-li><a href=/zh/docs/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-zhdocs><span>文档</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-zhdocshertz-li><a href=/zh/docs/hertz/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertz><span>Hertz</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzoverview-li><a href=/zh/docs/hertz/overview/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertzoverview><span>概览</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzgetting-started-li><a href=/zh/docs/hertz/getting-started/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertzgetting-started><span>快速开始</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-zhdocshertztutorials-li><a href=/zh/docs/hertz/tutorials/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorials><span>指南</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsexample-li><a href=/zh/docs/hertz/tutorials/example/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsexample><span>代码示例</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertztutorialsbasic-feature-li><a href=/zh/docs/hertz/tutorials/basic-feature/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsbasic-feature><span>基本特性</span></a><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featurenetwork-lib-li><a href=/zh/docs/hertz/tutorials/basic-feature/network-lib/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featurenetwork-lib><span>网络库</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertztutorialsbasic-featuremiddleware-li><a href=/zh/docs/hertz/tutorials/basic-feature/middleware/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsbasic-featuremiddleware><span>中间件概览</span></a><ul class="ul-5 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featuremiddlewarecors-li><a href=/zh/docs/hertz/tutorials/basic-feature/middleware/cors/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featuremiddlewarecors><span>跨源资源共享</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featuremiddlewarebasic-auth-li><a href=/zh/docs/hertz/tutorials/basic-feature/middleware/basic-auth/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featuremiddlewarebasic-auth><span>基本认证</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featuremiddlewarejwt-li><a href=/zh/docs/hertz/tutorials/basic-feature/middleware/jwt/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featuremiddlewarejwt><span>JWT认证</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featureprotocol-li><a href=/zh/docs/hertz/tutorials/basic-feature/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featureprotocol><span>协议</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featurebinding-and-validate-li><a href=/zh/docs/hertz/tutorials/basic-feature/binding-and-validate/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featurebinding-and-validate><span>绑定与校验</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featurestream-li><a href=/zh/docs/hertz/tutorials/basic-feature/stream/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featurestream><span>流式处理</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featureerror-handle-li><a href=/zh/docs/hertz/tutorials/basic-feature/error-handle/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featureerror-handle><span>错误处理</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featurelog-li><a href=/zh/docs/hertz/tutorials/basic-feature/log/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featurelog><span>日志</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featuregraceful-shutdown-li><a href=/zh/docs/hertz/tutorials/basic-feature/graceful-shutdown/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featuregraceful-shutdown><span>优雅退出</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featureforward-proxy-li><a href=/zh/docs/hertz/tutorials/basic-feature/forward-proxy/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featureforward-proxy><span>正向代理</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsbasic-featureunit-test-li><a href=/zh/docs/hertz/tutorials/basic-feature/unit-test/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsbasic-featureunit-test><span>单测</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertztutorialsservice-governance-li><a href=/zh/docs/hertz/tutorials/service-governance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsservice-governance><span>治理特性</span></a><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsservice-governancemonitoring-li><a href=/zh/docs/hertz/tutorials/service-governance/monitoring/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsservice-governancemonitoring><span>监控</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsservice-governancetracing-li><a href=/zh/docs/hertz/tutorials/service-governance/tracing/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsservice-governancetracing><span>链路追踪</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertztutorialsframework-exten-li><a href=/zh/docs/hertz/tutorials/framework-exten/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsframework-exten><span>框架扩展</span></a><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsframework-extenmonitor-li><a href=/zh/docs/hertz/tutorials/framework-exten/monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsframework-extenmonitor><span>监控扩展</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsframework-extenlog-li><a href=/zh/docs/hertz/tutorials/framework-exten/log/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsframework-extenlog><span>日志扩展</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertztutorialsframework-extenadvanced-exten-li><a href=/zh/docs/hertz/tutorials/framework-exten/advanced-exten/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialsframework-extenadvanced-exten><span>高级扩展</span></a><ul class="ul-5 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsframework-extenadvanced-extennetwork-lib-li><a href=/zh/docs/hertz/tutorials/framework-exten/advanced-exten/network-lib/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsframework-extenadvanced-extennetwork-lib><span>网络库扩展</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialsframework-extenadvanced-extenprotocol-li><a href=/zh/docs/hertz/tutorials/framework-exten/advanced-exten/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialsframework-extenadvanced-extenprotocol><span>协议扩展</span></a></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-zhdocshertztutorialstoolkit-li><a href=/zh/docs/hertz/tutorials/toolkit/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertztutorialstoolkit><span>hz 命令行工具</span></a><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-zhdocshertztutorialstoolkittoolkit-li><a href=/zh/docs/hertz/tutorials/toolkit/toolkit/ class="align-left pl-0 active td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialstoolkittoolkit><span class=td-sidebar-nav-active-item>hz 命令行工具使用</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertztutorialstoolkittemplate-li><a href=/zh/docs/hertz/tutorials/toolkit/template/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertztutorialstoolkittemplate><span>hz 自定义模板使用</span></a></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzfaq-li><a href=/zh/docs/hertz/faq/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertzfaq><span>常见问题</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zhdocshertzreference-li><a href=/zh/docs/hertz/reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zhdocshertzreference><span>参考</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzreferenceconfig-li><a href=/zh/docs/hertz/reference/config/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertzreferenceconfig><span>配置说明</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzreferenceversion-li><a href=/zh/docs/hertz/reference/version/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertzreferenceversion><span>版本说明</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zhdocshertzreferencejson-li><a href=/zh/docs/hertz/reference/json/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zhdocshertzreferencejson><span>JSON Marshal 库</span></a></li></ul></li></ul></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"><a href=https://github.com/cloudwego/cloudwego.github.io/edit/main/content/zh/docs/hertz/tutorials/toolkit/toolkit.md target=_blank><i class="fa fa-edit fa-fw"></i> 编辑此页</a>
<a href="https://github.com/cloudwego/cloudwego.github.io/new/main/content/zh/docs/hertz/tutorials/toolkit/toolkit.md?filename=change-me.md&value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" target=_blank><i class="fa fa-edit fa-fw"></i> 添加子页面</a>
<a href="https://github.com/cloudwego/cloudwego.github.io/issues/new?title=hz%20%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7%e4%bd%bf%e7%94%a8" target=_blank><i class="fab fa-github fa-fw"></i> 提交文档问题</a>
<a href=https://github.com/cloudwego/kitex/issues/new target=_blank><i class="fas fa-tasks fa-fw"></i> 提交项目问题</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#基本使用>基本使用</a><ul><li><a href=#new-创建一个-hertz-新项目>new: 创建一个 Hertz 新项目</a></li></ul></li><li><a href=#基于-thrift-idl-创建项目>基于 thrift IDL 创建项目</a><ul><li><a href=#new-创建一个新项目>new: 创建一个新项目</a></li><li><a href=#update-更新一个已有的项目>update: 更新一个已有的项目</a></li></ul></li><li><a href=#基于-protobuf-idl-创建项目>基于 protobuf IDL 创建项目</a><ul><li><a href=#new-创建一个新项目-1>new: 创建一个新项目</a></li><li><a href=#update-更新一个已有的项目-1>update: 更新一个已有的项目</a></li></ul></li><li><a href=#生成代码的结构>生成代码的结构</a></li><li><a href=#支持的-api-注解>支持的 api 注解</a><ul><li><a href=#支持的-api-注解-1>支持的 api 注解：</a></li><li><a href=#使用方法>使用方法：</a></li></ul></li><li><a href=#命令行参数说明>命令行参数说明</a><ul><li><a href=#global>Global:</a></li><li><a href=#new>New:</a></li><li><a href=#update>Update:</a></li></ul></li><li><a href=#注意事项>注意事项</a><ul><li><a href=#使用-protobuf-idl-的注意事项>使用 protobuf IDL 的注意事项</a></li><li><a href=#使用-thrift-idl-的注意事项>使用 thrift IDL 的注意事项</a></li><li><a href=#使用-update-命令时的行为说明>使用 update 命令时的行为说明</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><nav aria-label=breadcrumb class="d-none d-md-block d-print-none"><ol class="breadcrumb spb-1"><li class=breadcrumb-item><a href=/zh/docs/>文档</a></li><li class=breadcrumb-item><a href=/zh/docs/hertz/>Hertz</a></li><li class=breadcrumb-item><a href=/zh/docs/hertz/tutorials/>指南</a></li><li class=breadcrumb-item><a href=/zh/docs/hertz/tutorials/toolkit/>hz 命令行工具</a></li><li class="breadcrumb-item active" aria-current=page><a href=/zh/docs/hertz/tutorials/toolkit/toolkit/>hz 命令行工具使用</a></li></ol></nav><div class=td-content><h1>hz 命令行工具使用</h1><header class=article-meta></header><p>hz 是 Hertz 框架提供的一个用于生成代码的命令行工具。目前，hz 可以基于 thrift 和 protobuf 的 IDL 生成 Hertz 项目的脚手架。</p><h1 id=安装>安装</h1><ol><li>确保 <code>GOPATH</code> 环境变量已经被正确地定义（例如 <code>export GOPATH=~/go</code>）并且将<code>$GOPATH/bin</code>添加到 <code>PATH</code> 环境变量之中（例如 <code>export PATH=$GOPATH/bin:$PATH</code>）；请勿将 <code>GOPATH</code> 设置为当前用户没有读写权限的目录</li><li>安装 hz：</li></ol><pre><code>go install github.com/cloudwego/hertz/cmd/hz@latest
</code></pre><ol start=3><li>验证是否安装成功 <code>hz -v</code>, 如果显示如下版本的信息，则说明安装成功</li></ol><pre><code>hz version v0.1.0
</code></pre><p><strong>注意</strong>，由于 hz 会为自身的二进制文件创建软链接，因此请确保 hz 的安装路径具有可写权限。</p><h1 id=运行模式>运行模式</h1><p>要使用 thrift 或 protobuf 的 IDL 生成代码，需要安装相应的编译器：<a href=https://github.com/cloudwego/thriftgo>thriftgo</a> 或 <a href=https://github.com/protocolbuffers/protobuf/releases>protoc</a> 。</p><p>hz 生成的代码里，一部分是底层的编译器生成的（通常是关于 IDL 里定义的结构体），另一部分是IDL 中用户定义的路由、method 等信息。用户可直接运行该代码。</p><p>从执行流上来说，当 hz 使用 thrift IDL 生成代码时，hz 会调用 thriftgo 来生成 go 结构体代码，并将自身作为 thriftgo 的一个插件（名为 thrift-gen-hertz）来执行来生成其他代码。当用于 protobuf IDL 时亦是如此。</p><pre><code>$&gt; hz  ... --idl=IDL
    |
    | thrift-IDL
    |---------&gt; thriftgo --gen go:... -plugin=hertz:... IDL
    |
    | protobuf-IDL
     ---------&gt; protoc --hertz_out=... --hertz_opt=... IDL
</code></pre><p>如何安装thriftgo/protoc:</p><p>thriftgo:</p><pre><code>$ GO111MODULE=on go install github.com/cloudwego/thriftgo
</code></pre><p>protoc:</p><pre><code>// brew 安装
$ brew install protobuf

// 官方镜像安装，以 macos 为例
$ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protoc-3.19.4-osx-x86_64.zip
$ unzip protoc-3.19.4-osx-x86_64.zip
$ cp bin/protoc /usr/local/bin/protoc
// 确保 include/google 放入 /usr/local/include下
$ cp -r include/google /usr/local/include/google
</code></pre><h1 id=使用>使用</h1><h2 id=基本使用>基本使用</h2><h3 id=new-创建一个-hertz-新项目>new: 创建一个 Hertz 新项目</h3><ol><li>创建新项目</li></ol><pre><code>// GOPATH 下执行，go mod 名字默认为当前路径相对GOPATH的路径，也可自己指定
hz new

// 非GOPATH 下执行，需要指定 go mod 名
hz new -mod hertz/demo

// 整理 &amp; 拉取依赖
go mod tidy
</code></pre><p>执行后会在当前目录下生成 Hertz 项目的脚手架。</p><ol start=2><li>编译项目</li></ol><pre><code>go build
</code></pre><ol start=3><li>运行项目并测试</li></ol><p>运行项目：</p><pre><code>./{{your binary}}
</code></pre><p>测试：</p><pre><code>curl 127.0.0.1:8888/ping
</code></pre><p>如果返回<code>{"message":"pong"}</code>，说明接口调通。</p><h2 id=基于-thrift-idl-创建项目>基于 thrift IDL 创建项目</h2><h3 id=new-创建一个新项目>new: 创建一个新项目</h3><ol><li>在当前目录下创建 thrift idl 文件</li></ol><pre><code>// idl/hello.thrift
namespace go hello.example

struct HelloReq {
    1: string Name (api.query=&quot;name&quot;); // 添加 api 注解为方便进行参数绑定
}

struct HelloResp {
    1: string RespBody;
}


service HelloService {
    HelloResp HelloMethod(1: HelloReq request) (api.get=&quot;/hello&quot;);
}
</code></pre><ol start=2><li>创建新项目</li></ol><pre><code>// GOPATH 下执行
hz new -idl idl/hello.thrift

// 整理 &amp; 拉取依赖
go mod tidy
</code></pre><ol start=3><li>修改handler，添加自己的逻辑</li></ol><pre><code>// handler path: biz/handler/hello/example/hello_service.go
// 其中 &quot;hello/example&quot; 是 thrift idl 的 namespace
// &quot;hello_service.go&quot; 是 thrift idl 中 service 的名字，所有 service 定义的方法都会生成在这个文件中

// HelloMethod .
// @router /hello [GET]
func HelloMethod(ctx context.Context, c *app.RequestContext) {
        var err error
        var req example.HelloReq
        err = c.BindAndValidate(&amp;req)
        if err != nil {
                c.String(400, err.Error())
                return
        }

        resp := new(example.HelloResp)

        // 你可以修改整个函数的逻辑，而不仅仅局限于当前模板
        resp.RespBody = &quot;hello,&quot; + req.Name // 添加的逻辑

        c.JSON(200, resp)
}
</code></pre><ol start=4><li>编译项目</li></ol><pre><code>go build
</code></pre><ol start=5><li>运行项目并测试</li></ol><p>运行项目：</p><pre><code>./{{your binary}}
</code></pre><p>测试：</p><pre><code>curl --location --request GET 'http://127.0.0.1:8888/hello?name=hertz'
</code></pre><p>如果返回<code>{"RespBody":"hello,hertz"}</code>，说明接口调通。</p><h3 id=update-更新一个已有的项目>update: 更新一个已有的项目</h3><ol><li>如果你的 thrift idl 有更新，例如：</li></ol><pre><code>// idl/hello.thrift
namespace go hello.example

struct HelloReq {
    1: string Name (api.query=&quot;name&quot;);
}

struct HelloResp {
    1: string RespBody;
}

struct OtherReq {
    1: string Other (api.body=&quot;other&quot;);
}

struct OtherResp {
    1: string Resp;
}


service HelloService {
    HelloResp HelloMethod(1: HelloReq request) (api.get=&quot;/hello&quot;);
    OtherResp OtherMethod(1: OtherReq request) (api.post=&quot;/other&quot;);
}

service NewService {
    HelloResp NewMethod(1: HelloReq request) (api.get=&quot;/new&quot;);
}
</code></pre><ol start=2><li>切换到执行 new 命令的目录，更新修改后的 thrift idl</li></ol><pre><code>hz update -idl idl/hello.thrift
</code></pre><ol start=3><li><p>可以看到</p><p>在 &ldquo;biz/handler/hello/example/hello_service.go&rdquo; 下新增了新的方法<br>在 &ldquo;biz/handler/hello/example&rdquo; 下新增了文件 &ldquo;new_service.go&rdquo; 以及对应的 &ldquo;NewMethod&rdquo; 方法。</p></li></ol><p>下面我们来开发 &ldquo;OtherMethod&rdquo; 接口</p><pre><code>// HelloMethod .
// @router /hello [GET]
func HelloMethod(ctx context.Context, c *app.RequestContext) {
   var err error
   var req example.HelloReq
   err = c.BindAndValidate(&amp;req)
   if err != nil {
      c.String(400, err.Error())
      return
   }

   resp := new(example.HelloResp)

   // 你可以修改整个函数的逻辑，而不仅仅局限于当前模板
   resp.RespBody = &quot;hello,&quot; + req.Name // 添加的逻辑

   c.JSON(200, resp)
}

// OtherMethod .
// @router /other [POST]
func OtherMethod(ctx context.Context, c *app.RequestContext) {
   var err error
   // example.OtherReq 对应的model文件也会重新生成
   var req example.OtherReq
   err = c.BindAndValidate(&amp;req)
   if err != nil {
      c.String(400, err.Error())
      return
   }

   resp := new(example.OtherResp)

   // 增加的逻辑
   resp.Resp = &quot;Other method: &quot; + req.Other

   c.JSON(200, resp)
}
</code></pre><ol start=4><li>编译项目</li></ol><pre><code>go build
</code></pre><ol start=5><li>运行项目并测试</li></ol><p>运行项目：</p><pre><code>./{{your binary}}
</code></pre><p>测试：</p><pre><code>curl --location --request POST 'http://127.0.0.1:8888/other' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;Other&quot;: &quot;other method&quot;
}'
</code></pre><p>如果返回<code>{"Resp":"Other method: other method"}</code>，说明接口调通。</p><h2 id=基于-protobuf-idl-创建项目>基于 protobuf IDL 创建项目</h2><h3 id=new-创建一个新项目-1>new: 创建一个新项目</h3><ol><li><p>在当前目录下创建 protobuf idl 文件</p><p><em>注</em>：为在 protobuf 中支持 api 注解，请在使用了注解的 proto 文件中，import 下面的文件</p></li></ol><pre><code>// idl/api.proto; 注解拓展
syntax = &quot;proto2&quot;;

package api;

import &quot;google/protobuf/descriptor.proto&quot;;

option go_package = &quot;/api&quot;;

extend google.protobuf.FieldOptions {
  optional string raw_body = 50101;
  optional string query = 50102;
  optional string header = 50103;
  optional string cookie = 50104;
  optional string body = 50105;
  optional string path = 50106;
  optional string vd = 50107;
  optional string form = 50108;
  optional string go_tag = 51001;
  optional string js_conv = 50109;
}

extend google.protobuf.MethodOptions {
  optional string get = 50201;
  optional string post = 50202;
  optional string put = 50203;
  optional string delete = 50204;
  optional string patch = 50205;
  optional string options = 50206;
  optional string head = 50207;
  optional string any = 50208;
  optional string gen_path = 50301;
  optional string api_version = 50302;
  optional string tag = 50303;
  optional string name = 50304;
  optional string api_level = 50305;
  optional string serializer = 50306;
  optional string param = 50307;
  optional string baseurl = 50308;
}

extend google.protobuf.EnumValueOptions {
  optional int32 http_code = 50401;
}
</code></pre><p>主 idl 定义：</p><pre><code>// idl/hello/hello.proto
syntax = &quot;proto3&quot;;

package hello;

option go_package = &quot;hertz/hello&quot;;

import &quot;api.proto&quot;;

message HelloReq {
  string Name = 1[(api.query)=&quot;name&quot;];
}

message HelloResp {
  string RespBody = 1;
}

service HelloService {
  rpc Method1(HelloReq) returns(HelloResp) {
    option (api.get) = &quot;/hello&quot;;
  }
}
</code></pre><ol start=2><li>创建新项目</li></ol><pre><code>// GOPATH 下执行, 如果主IDL的依赖和主IDL不在同一路径下，需要加入 -I 选项，其含义为IDL搜索路径，等同于 protoc 的 -I 命令
hz new -I idl -idl idl/hello/hello.proto

// 整理 &amp; 拉取依赖
go mod tidy
</code></pre><ol start=3><li>修改handler，添加自己的逻辑</li></ol><pre><code>// handler path: biz/handler/hello/hello_service.go
// 其中 &quot;/hello&quot; 是 protobuf idl 中 go_package 的最后一级
// &quot;hello_service.go&quot; 是 protobuf idl 中 service 的名字，所有 service 定义的方法都会生成在这个文件中

// Method1 .
// @router /hello [GET]
func Method1(ctx context.Context, c *app.RequestContext) {
   var err error
   var req hello.HelloReq
   err = c.BindAndValidate(&amp;req)
   if err != nil {
      c.String(400, err.Error())
      return
   }

   resp := new(hello.HelloResp)

   // 你可以修改整个函数的逻辑，而不仅仅局限于当前模板
   resp.RespBody = &quot;hello,&quot; + req.Name // 添加的逻辑

   c.JSON(200, resp)
}
</code></pre><ol start=4><li>编译项目</li></ol><pre><code>go build
</code></pre><ol start=5><li>运行项目并测试</li></ol><p>运行项目：</p><pre><code>./{{your binary}}
</code></pre><p>测试：</p><pre><code>curl --location --request GET 'http://127.0.0.1:8888/hello?name=hertz'
</code></pre><p>如果返回<code>{"RespBody":"hello,hertz"}</code>，说明接口调通。</p><h3 id=update-更新一个已有的项目-1>update: 更新一个已有的项目</h3><ol><li>如果你的 protobuf idl 有更新，例如：</li></ol><pre><code>// idl/hello/hello.proto
syntax = &quot;proto3&quot;;

package hello;

option go_package = &quot;hertz/hello&quot;;

import &quot;api.proto&quot;;

message HelloReq {
  string Name = 1[(api.query)=&quot;name&quot;];
}

message HelloResp {
  string RespBody = 1;
}

message OtherReq {
  string Other = 1[(api.body)=&quot;other&quot;];
}

message OtherResp {
  string Resp = 1;
}

service HelloService {
  rpc Method1(HelloReq) returns(HelloResp) {
    option (api.get) = &quot;/hello&quot;;
  }
  rpc Method2(OtherReq) returns(OtherResp) {
    option (api.post) = &quot;/other&quot;;
  }
}

service NewService {
  rpc Method3(OtherReq) returns(OtherResp) {
    option (api.get) = &quot;/new&quot;;
  }
}
</code></pre><ol start=2><li>切换到执行 new 命令的目录，更新修改后的 protobuf idl</li></ol><pre><code>hz update -I idl -idl idl/hello/hello.proto
</code></pre><ol start=3><li>可以看到 &ldquo;biz/handler/hello/hello_service.go&rdquo; 下新增了新的方法，在 &ldquo;biz/handler/hello&rdquo; 下新增了文件 &ldquo;new_service.go&rdquo; 以及对应的 &ldquo;Method3&rdquo; 方法。</li></ol><p>下面我们来开发 &ldquo;Method2&rdquo; 接口</p><pre><code>// Method1 .
// @router /hello [GET]
func Method1(ctx context.Context, c *app.RequestContext) {
   var err error
   var req hello.HelloReq
   err = c.BindAndValidate(&amp;req)
   if err != nil {
      c.String(400, err.Error())
      return
   }

   resp := new(hello.HelloResp)

   // 你可以修改整个函数的逻辑，而不仅仅局限于当前模板
   resp.RespBody = &quot;hello,&quot; + req.Name // 添加的逻辑

   c.JSON(200, resp)
}

// Method2 .
// @router /other [POST]
func Method2(ctx context.Context, c *app.RequestContext) {
   var err error
   var req hello.OtherReq
   err = c.BindAndValidate(&amp;req)
   if err != nil {
      c.String(400, err.Error())
      return
   }

   resp := new(hello.OtherResp)

   // 增加的逻辑
   resp.Resp = &quot;Other method: &quot; + req.Other

   c.JSON(200, resp)
}
</code></pre><ol start=4><li>编译项目</li></ol><pre><code>go build
</code></pre><ol start=5><li>运行项目并测试</li></ol><p>运行项目：</p><pre><code>./{{your binary}}
</code></pre><p>测试：</p><pre><code>curl --location --request POST 'http://127.0.0.1:8888/other' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;Other&quot;: &quot;other method&quot;
}'
</code></pre><p>如果返回<code>{"Resp":"Other method: other method"}</code>，说明接口调通。</p><h2 id=生成代码的结构>生成代码的结构</h2><p>hz 生成的代码结构都类似，下面以"基于 thrift IDL 创建项目"小节生成的代码结构为例，说明hz生成的代码的含义。</p><pre><code>.
├── biz                                // business 层，存放业务逻辑相关流程
│   ├── handler                        // 存放 handler 文件
│   │   ├── hello                      // hello/example 对应 thrift idl 中定义的 namespace；而对于 protobuf idl，则是对应 go_package 的最后一级
│   │   │   └── example
│   │   │       ├── hello_service.go   // handler 文件，用户在该文件里实现 IDL service 定义的方法，update 时会查找 当前文件已有的 handler 在尾部追加新的 handler
│   │   │       └── new_service.go     // 同上，idl 中定义的每一个 service 对应一个文件
│   │   └── ping.go                    // 默认携带的 ping handler，用于生成代码快速调试，无其他特殊含义
│   ├── model                          // IDL 内容相关的生成代码
│   │   └── hello                      // hello/example 对应 thrift idl 中定义的 namespace；而对于 protobuf idl，则是对应 go_package
│   │     └── example
│   │         └── hello.go             // thriftgo 的产物，包含 hello.thrift 定义的内容的 go 代码，update 时会重新生成
│   └── router                         // idl 中定义的路由相关生成代码
│       ├── hello                      // hello/example 对应 thrift idl 中定义的namespace；而对于 protobuf idl，则是对应 go_package 的最后一级
│       │   └── example
│       │       ├── hello.go           // hz 为 hello.thrift 中定义的路由生成的路由注册代码；每次 update 相关 idl 会重新生成该文件
│       │       └── middleware.go      // 默认中间件函数，hz 为每一个生成的路由组都默认加了一个中间件；update 时会查找当前文件已有的 middleware 在尾部追加新的 middleware
│       └── register.go                // 调用注册每一个 idl 文件中的路由定义；当有新的 idl 加入，在更新的时候会自动插入其路由注册的调用；勿动
├── go.mod                             // go.mod 文件，如不在命令行指定，则默认使用相对于GOPATH的相对路径作为 module 名
├── idl                                // 用户定义的idl，位置可任意
│   └── hello.thrift
├── main.go                            // 程序入口
├── router.go                          // 用户自定义除 idl 外的路由方法
└── router_gen.go                      // hz 生成的路由注册代码，用于调用用户自定义的路由以及 hz 生成的路由
</code></pre><h2 id=支持的-api-注解>支持的 api 注解</h2><blockquote><p>Field 注解可用于<a href=https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/binding-and-validate/>参数绑定及校验</a></p><p>Method 注解可用于生成路由注册相关代码</p></blockquote><h3 id=支持的-api-注解-1>支持的 api 注解：</h3><table><thead><tr><th><em>Field 注解</em></th><th></th></tr></thead><tbody><tr><td>注解</td><td>说明</td></tr><tr><td>api.raw_body</td><td>生成 &ldquo;raw_body&rdquo; tag</td></tr><tr><td>api.query</td><td>生成 &ldquo;query&rdquo; tag</td></tr><tr><td>api.header</td><td>生成 &ldquo;header&rdquo; tag</td></tr><tr><td>api.cookie</td><td>生成 &ldquo;cookie&rdquo; tag</td></tr><tr><td>api.body</td><td>生成 &ldquo;json&rdquo; tag</td></tr><tr><td>api.path</td><td>生成 &ldquo;path&rdquo; tag</td></tr><tr><td>api.form</td><td>生成 &ldquo;form&rdquo; tag</td></tr><tr><td>api.go_tag (protobuf)<br>go.tag (thrift)</td><td>透传go_tag，会生成go_tag里定义的内容</td></tr><tr><td>api.vd</td><td>生成 &ldquo;vd&rdquo; tag</td></tr></tbody></table><table><thead><tr><th><em>Method 注解</em></th><th></th></tr></thead><tbody><tr><td>注解</td><td>说明</td></tr><tr><td>api.get</td><td>定义 GET 方法及路由</td></tr><tr><td>api.post</td><td>定义 POST 方法及路由</td></tr><tr><td>api.put</td><td>定义 PUT 方法及路由</td></tr><tr><td>api.delete</td><td>定义 DELETE 方法及路由</td></tr><tr><td>api.patch</td><td>定义 PATCH 方法及路由</td></tr><tr><td>api.options</td><td>定义 OPTIONS 方法及路由</td></tr><tr><td>api.head</td><td>定义 HEAD 方法及路由</td></tr><tr><td>api.any</td><td>定义 ANY 方法及路由</td></tr></tbody></table><h3 id=使用方法>使用方法：</h3><h4 id=field-注解>Field 注解：</h4><p>Thrift：</p><pre><code>struct Demo {
    1: string Demo (api.query=&quot;demo&quot;, api.path=&quot;demo&quot;);
    2: string GoTag (go.tag=&quot;goTag:&quot;tag&quot;&quot;);
    3: string Vd (api.vd=&quot;$!='your string'&quot;);
}
</code></pre><p>Protobuf:</p><pre><code>message Demo {
  string Demo = 1[(api.query)=&quot;demo&quot;,(api.path)=&quot;demo&quot;];
  string GoTag = 2[(api.go_tag)=&quot;goTag:&quot;tag&quot;&quot;];
  string Vd = 3[(api.vd)=&quot;$!='your string'&quot;];
}
</code></pre><h4 id=method-注解>Method 注解：</h4><p>Thrift：</p><pre><code>service Demo {
    Resp Method(1: Req request) (api.get=&quot;/route&quot;);
}
</code></pre><p>Protobuf:</p><pre><code>service Demo {
  rpc Method(Req) returns(Resp) {
    option (api.get) = &quot;/route&quot;;
  }
}
</code></pre><h2 id=命令行参数说明>命令行参数说明</h2><h3 id=global>Global:</h3><pre><code>$ hz --help
NAME:
   hz - A idl parser and code generator for Hertz projects

USAGE:
   hz [global options] command [command options] [arguments...]

VERSION:
   0.0.1

COMMANDS:
   new      Generate a new Hertz project
   update   Update an existing Hertz project
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help (default: false)
   --verbose      turn on verbose mode (default: false)
   --version, -v  print the version (default: false)
</code></pre><ul><li>New: 创建一个新的 Hertz 项目</li></ul><ul><li>update: 更新一个已存在的 Hertz 项目</li></ul><h3 id=new>New:</h3><pre><code>$ hz help new
NAME:
   hz new - Generate a new Hertz project

USAGE:
   hz new [command options] [arguments...]

OPTIONS:
   --client_dir value                Specify the client path. If not specified, no client code is generated.
   --customize_layout value          Specify the layout template. ({{Template Profile}}:{{Rendering Data}})
   --customize_package value         Specify the package template. ({{Template Profile}}:)
   --exclude_file value, -E value    Specify the files that do not need to be updated.  (accepts multiple inputs)
   --handler_dir value               Specify the handler path.
   --idl value                       Specify the IDL file path. (.thrift or .proto)  (accepts multiple inputs)
   --json_enumstr                    Use string instead of num for json enums when idl is thrift. (default: false)
   --model_dir value                 Specify the model path.
   --module value, --mod value       Specify the Go module name to generate go.mod.
   --no_recurse                      Generate master model only. (default: false)
   --option_package value, -P value  Specify the package path. ({include_path}={import_path})  (accepts multiple inputs)
   --out_dir value                   Specify the project path.
   --proto_path value, -I value      Add an IDL search path for includes. (Valid only if idl is protobuf)  (accepts multiple inputs)
   --protoc value, -p value          Specify arguments for the protoc. ({flag}={value})                    (accepts multiple inputs)
   --service value                   Specify the service name.
   --snake_tag                       Use snake_case style naming for tags. (Only works for 'form', 'query', 'json') (default: false)
   --thriftgo value, -t value        Specify arguments for the thriftgo. ({flag}={value})  (accepts mul
</code></pre><ul><li>client_dir: 指定 client 侧代码的生成路径，如果不指定则不生成；当前为每个 service 生成一个全局的client，后续会提供更丰富的 client 代码能力</li></ul><ul><li>customize_layout: 自定义项目 layout 模板，具体详见：<a href=https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/template/>自定义模板使用</a></li></ul><ul><li>customize_package: 自定义项目 package 相关模板，主要可针对 handler 模板进行定制化，具体详见：<a href=https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/template/>自定义模板使用</a></li></ul><ul><li>exclude_file: 不需要更新的文件(相对项目路径，支持多个)</li></ul><ul><li>handler_dir: 指定 handler 的生成路径，默认为 &ldquo;biz/handler&rdquo;</li></ul><ul><li>idl: idl 文件路径(.thrift 或者.proto)</li></ul><ul><li>json_enumstr: 当 idl 为 thrift 时，json enums 使用 string 代替 num(透传给 thriftgo 的选项)</li></ul><ul><li>model_dir: 指定 model 的生成路径，默认为"biz/model"</li></ul><ul><li>module/mod: 指定 go mod 的名字，非 GOPATH 下必须指定，GOPATH 下默认以相对于GOPATH 的路径作为名字</li></ul><ul><li>no_recurse: 只生成主 idl 的 model 代码</li></ul><ul><li>option_package/P: 指定包的路径，({include_path}={import_path})</li></ul><ul><li>out_dir: 指定项目生成路径</li></ul><ul><li>proto_path/I: 当 idl 为 protobuf 时，指定 idl 的搜索路径，同 protoc 的 -I 指令</li></ul><ul><li>protoc/p: 透传给 protoc 的选项({flag}={value})</li></ul><ul><li>service: 服务名，为之后做服务发现等功能预留</li></ul><ul><li>snake_tag: tag 使用 snake_case 风格命名(仅对 form、query、json 生效)</li></ul><ul><li>thriftgo/t: 透传给 thriftgo 的选项({flag}={value})</li></ul><ul><li>unset_omitempty: 当 idl 为 protobuf 时，生成 model field，去掉 omitempty tag；当 idl 为 thrift 时，是否添加 omitempty 根据 field 是 &ldquo;optional"还是"required"决定</li></ul><h3 id=update>Update:</h3><pre><code>$ hz help update
NAME:
   hz update - Update an existing Hertz project

USAGE:
   hz update [command options] [arguments...]

OPTIONS:
   --client_dir value                Specify the client path. If not specified, no client code is generated.
   --customize_package value         Specify the package template. ({{Template Profile}}:)
   --exclude_file value, -E value    Specify the files that do not need to be updated.  (accepts multiple inputs)
   --handler_dir value               Specify the handler path.
   --idl value                       Specify the IDL file path. (.thrift or .proto)  (accepts multiple inputs)
   --json_enumstr                    Use string instead of num for json enums when idl is thrift. (default: false)
   --model_dir value                 Specify the model path.
   --no_recurse                      Generate master model only. (default: false)
   --option_package value, -P value  Specify the package path. ({include_path}={import_path})  (accepts multiple inputs)
   --out_dir value                   Specify the project path.
   --proto_path value, -I value      Add an IDL search path for includes. (Valid only if idl is protobuf)  (accepts multiple inputs)
   --protoc value, -p value          Specify arguments for the protoc. ({flag}={value})                    (accepts multiple inputs)
   --snake_tag                       Use snake_case style naming for tags. (Only works for 'form', 'query', 'json') (default: false)
   --thriftgo value, -t value        Specify arguments for the thriftgo. ({flag}={value})  (accepts multiple inputs)
   --unset_omitempty                 Remove 'omitempty' tag for generated struct. (default: false)
</code></pre><ul><li>client_dir: 指定 client 侧代码的生成路径，如果不指定则不生成；当前为每个 service 生成一个全局的client，后续会提供更丰富的 client 代码能力。注意：如果对同一套 idl 进行update，需要 client_dir 的值与使用 new 的时候相同，否则会生成冗余的代码，需要用户自行删除。</li></ul><ul><li>customize_package: 自定义项目 package 相关模板，主要可针对 handler 模板进行定制化，具体详见：<a href=https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/template/>自定义模板使用</a> 。注意：对于已经存在的 handler 文件会按照默认模板新增 handler 函数，对于还未存在的 handler 文件，则会按照自定义模板来生成 handler。</li></ul><ul><li>exclude_file: 不需要更新的文件(相对项目路径，支持多个)</li></ul><ul><li>handler_dir: 指定 handler 的生成路径，默认为"biz/handler&rdquo;；注意：如果对同一套 idl 进行update，需要 handler_dir 的值与使用 new 的时候相同，否则会生成冗余的代码，需要用户自行删除。</li></ul><ul><li>idl: idl 文件路径(.thrift 或者.proto)</li></ul><ul><li>json_enumstr: 当 idl 为 thrift 时，json enums 使用 string 代替 num(透传给 thriftgo 的选项)</li></ul><ul><li>model_dir: 指定 model 的生成路径，默认为"biz/model"；注意：如果对同一套 idl 进行update，需要 model_dir 的值与使用 new 的时候相同，否则会生成重复的 model 代码且导致 handler 引用不一致。</li></ul><ul><li>no_recurse: 只生成主 idl 的 model 代码</li></ul><ul><li>option_package/P: 指定包的路径，({include_path}={import_path})</li></ul><ul><li>out_dir: 指定项目生成路径</li></ul><ul><li>proto_path/I: 当 idl 为 protobuf 时，指定 idl 的搜索路径，同 protoc 的 -I 指令</li></ul><ul><li>protoc/p: 透传给 protoc 的选项({flag}={value})</li></ul><ul><li>snake_tag: tag 使用 snake_case 风格命名(仅对 form、query、json 生效)</li></ul><ul><li>thriftgo/t: 透传给 thriftgo 的选项({flag}={value})</li></ul><ul><li>unset_omitempty: 当 idl 为 protobuf 时，生成 model field，去掉 mitempty tag；当 idl 为 thrift 时，是否添加 omitempty 根据 field 是 &ldquo;optional"还是"required"决定</li></ul><h2 id=注意事项>注意事项</h2><h3 id=使用-protobuf-idl-的注意事项>使用 protobuf IDL 的注意事项</h3><p>hz 目前支持 <a href=https://developers.google.com/protocol-buffers/docs/proto>proto2</a> / <a href=https://developers.google.com/protocol-buffers/docs/proto3>proto3</a> 的语法</p><p><strong>我们希望用户在定义 protobuf idl 的时候指定 go_package</strong>，这样一来符合 protobuf 的语义，二来生成的 model 位置可以通过 go_package来决定。如果用户不指定 go_package，hz 会默认将 proto文件的 package 做为 go_package，可能会有一些预期外的命名冲突。</p><p>例如，可以这样定义 go_package</p><pre><code>option go_package = &quot;hello.world&quot;; // or hello/world
</code></pre><p>model 生成的路径会是：</p><p><code>${项目路径}/${model_dir}/hello/world</code></p><p>handler 文件会取 go_package 最后一级作为生成路径，其生成路径会是：</p><p><code>${项目路径}/${handler_dir}/world</code></p><p>router 注册文件同样会取 go_package 最后一级作为生成路径，其生成路径会是：</p><p><code>${项目路径}/biz/router/world</code></p><h3 id=使用-thrift-idl-的注意事项>使用 thrift IDL 的注意事项</h3><p><strong>hz 对于 thrift idl 的定义无特殊要求</strong>，符合语法规范即可。代码的生成路径会和 thrift 的 namespace 相关。</p><p>例如，可以这样定义 namespace</p><pre><code> namespace go hello.world
</code></pre><p>model 生成的路径会是：</p><p><code>${项目路径}/${model_dir}/hello/world</code></p><p>handler 文件会取 namespace 作为生成路径，其生成路径会是：</p><p><code>${项目路径}/${handler_dir}/hello/world</code></p><p>router 注册文件同样会取 namespace 作为生成路径，其生成路径会是：</p><p><code>${项目路径}/biz/router/hello/world</code></p><h3 id=使用-update-命令时的行为说明>使用 update 命令时的行为说明</h3><ol><li>使用自定义路径的注意事项</li></ol><p>hz 为了用户使用方便，提供了自定义 handler 路径、model 路径、模板等功能。但是 hz 在创建一个新项目的时候并没有保存当前项目的信息，所以在使用 update 命令时可以认为是一种无状态的更新。因此对于同一套 idl 在 new 和 update 的时候，使用了不同的自定义信息，可能会产生重复的代码，举个例子，如下：</p><p>创建新项目：</p><pre><code>hz new -idl demo.thrift

此时，hz 会把 model 生成在 &quot;biz/mdoel&quot;下
</code></pre><p>更新项目：</p><pre><code>hz update -idl demo.thrift --model_dir=my_model

此时，hz 不会更新&quot;biz/model&quot;下的 model 代码，而是会在&quot;my_model&quot;下；这时&quot;biz/model&quot;和&quot;my_model&quot;下的代码就会重复，且新生成的handler会依赖&quot;my_model&quot;，之前的handler会依赖&quot;biz/model&quot;，这时就需要用户手动删除&amp;改动一些代码了。
</code></pre><p>因此，<strong>我们希望用户使用 update 命令的时候，自定义的路径 &ldquo;client_dir&rdquo;、&ldquo;model_dir&rdquo;、&ldquo;handler_dir&rdquo;，最好 new 和相同。</strong></p><ol start=2><li>update handler的行为</li></ol><p>hz 在 new 项目的时候会根据默认模板/自定义模板来生成 handler，其中每个 service 生成一个文件，该文件包含了该 service 定义的所有 handler 代码；如果 idl 定义了多个 service，则每个 service 都会生成一个文件，这些文件都在同一路径下；举个例子：</p><pre><code>// demo.thrift
namespace go hello.example

service Service1 {
    HelloResp Method1(1: HelloReq request) (api.get=&quot;/hello&quot;);
}

service Service2 {
    HelloResp Method2(1: HelloReq request) (api.get=&quot;/new&quot;);
}

// 那么该 idl 生成的 handler 文件如下：
${handler_dir}/${namespace}/service1.go -&gt; method1
${handler_dir}/${namespace}/service2.go -&gt; method2
</code></pre><p><strong>当该 idl 增加了新的 method 后，就会在对应 service 的文件的末尾追加 handler 模板；注意这里追加的 handler 会使用默认的模板，新生成 service 文件会根据情况使用自定义模板。</strong></p><ol start=3><li>update router 的行为</li></ol><p>hz 在 new 的时候生成的 router 代码主要有如下三个：</p><ul><li>biz/router/${namespace}/${idlName}.go: 每个主 idl 都会生成对应的路由注册代码文件，该文件以路由组的方式注册 idl 中定义的所有路由，并设置默认的中间件。</li></ul><ul><li>biz/router/${namespace}/middleware.go: 每个主 idl 对应的默认中间件函数，用户可修改中间件函数，以此为特定的路由增加特定的中间件逻辑。</li></ul><ul><li>biz/router/register.go：该文件负责调用不同 idl 生成的路由注册；比如我在两个 idl &ldquo;demo1.thrift&rdquo;、&ldquo;demo2.thrift"中都定义了 service ，那么这两个文件都会生成对应的路由注册代码。register.go 负责调用这两部分的路由注册函数。</li></ul><p>基于上述描述，给出 router 在 update 时的行为描述：</p><ul><li>biz/${namespace}/${idlName}.go: 每次都基于 idl 重新生成，用户不要改该文件代码，否则会丢失代码。</li></ul><ul><li>biz/${namespace}/middleware.go: 每次都会在尾部追加目前没有的 middleware。</li></ul><ul><li>biz/router/register.go: 如果有新增的 idl 会插入新的 idl 的路由注册方式。</li></ul><style>.feedback--answer{display:inline-block}.feedback--answer-no{margin-left:1em}.feedback--response{display:none;margin-top:1em}.feedback--response__visible{display:block}</style><div class=d-print-none><h2 class=feedback--title>反馈</h2><p class=feedback--question>当前页面对你有帮助吗？</p><button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">是</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">否</button><p class="feedback--response feedback--response-yes"><a href=https://github.com/cloudwego/cloudwego.github.io/issues/new>请告诉我们如何改进</a>.</p><p class="feedback--response feedback--response-no"><a href=https://github.com/cloudwego/cloudwego.github.io/issues/new>请告诉我们如何改进</a>.</p></div><script>const yesButton=document.querySelector('.feedback--answer-yes'),noButton=document.querySelector('.feedback--answer-no'),yesResponse=document.querySelector('.feedback--response-yes'),noResponse=document.querySelector('.feedback--response-no'),disableButtons=()=>{yesButton.disabled=!0,noButton.disabled=!0},sendFeedback=b=>{if(typeof ga!='function')return;const a={command:'send',hitType:'event',category:'Helpful',action:'click',label:window.location.pathname,value:b};ga(a.command,a.hitType,a.category,a.action,a.label,a.value)};yesButton.addEventListener('click',()=>{yesResponse.classList.add('feedback--response__visible'),disableButtons(),sendFeedback(1)}),noButton.addEventListener('click',()=>{noResponse.classList.add('feedback--response__visible'),disableButtons(),sendFeedback(0)})</script><br><div class="text-muted mt-5 pt-3 border-top">最后修改
June 27, 2022
: <a href=https://github.com/cloudwego/cloudwego.github.io/commit/83547433debb7b060251e66e13494540f1882aec>docs(community): update link to recent-activity (#230) (8354743)</a></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 The CloudWeGo Authors</small><p class="mt-2 text-white"><a class=cloudwego-link href=/about/ target=_blank rel=noopener>About</a>
|
<a class=cloudwego-link href=https://github.com/cloudwego/cloudwego.github.io/blob/main/LICENSE target=_blank rel=noopener>License</a></p></div></div></div></footer></div><script src=https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.staticfile.org/bootstrap/4.6.0/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script></body></html>